本项目是“享元”模式的 例子代码


享元模式: 以共享的方式高效地支持大量的细粒度对象。

享元对象的状态:
 
1、内蕴状态(Internal State)内蕴状态存储在享元对象内部且不会随环境改变而改变。因此内蕴状态并可以共享。
 
2、外蕴状态(External State)。外蕴状态是随环境改变而改变的、不可以共享的状态。
享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。
外蕴状态与内蕴状态是相互独立的。

享元模式的应用条件：

1、一个系统有大量的对象。
2、这些对象耗费大量的内存。
3、这些对象的状态中的大部分都可以外部化。
4、这些对象可以按照内蕴状态分成很多的组，当把外蕴对象从对象中剔除时，每一个组都可以仅用一个对象代替。
5、软件系统不依赖于这些对象的身份，换言之，这些对象可以是不可分辨的。


.NET的享元模式：
  .NET中的String类型就是运用了享元模式。
  .NET中如果第一次创建了一个字符串对象s1，
  下次再创建相同的字符串s2时只是把它的引用指向s1所引用的具体对象，这就实现了相同字符串在内存中的共享。


============================================================================

享元模式的分类：

  1、单纯享元模式

  2、复合享元模式 


============================================================================



单纯享元模式构成说明：

1、抽象享元(Flyweight)角色：
此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。
那些需要外蕴状态(External State)的操作可以通过调用商业方法以参数形式传入。


2、具体享元(ConcreteFlyweight)角色：
实现抽象享元角色所规定的接口。
如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。
享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享的。


3、享元工厂(FlyweightFactory)角色：
本角色负责创建和管理享元角色。
本角色必须保证享元对象可以被系统适当地共享。
当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个复合要求的享元对象。
如果已经有了，享元工厂角色就应当提供这个已有的享元对象；
如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。

注意：客户端不可以直接实例化享元类,必须通过享元工厂类来创建,
因为享元工厂类在系统中只能有一个,所以可以结合单例模式来改善。
当客户端需要单纯享元对象时，需要调用享元工厂的Singleton()方法，
此时工厂会取得所有的单纯享元对象，然后传入所需的单纯享元对象的内蕴状态，工厂方法负责产生所需要的享元对象。 


4、客户端(Client)角色：
需要维护一个对所有享元对象的引用;需要自行存储所有享元对象外蕴状态。


=========================================================================


结构对象说明：

1、抽象享元角色：
此角色是所有的具体享元类的超类，为这些类规定出需要实现的公共接口。
那些需要外蕴状态(External State)的操作可以通过方法的参数传入。
抽象享元的接口使得享元变得可能，但是并不强制子类实行共享，因此并非所有的享元对象都是可以共享的。


2、具体享元(ConcreteFlyweight)角色：
实现抽象享元角色所规定的接口。
如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。
享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享。
有时候具体享元角色又叫做单纯具体享元角色，因为复合享元角色是由单纯具体享元角色通过复合而成的。


3、复合享元(UnsharableFlyweight)角色：
复合享元角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。
复合享元角色又称做不可共享的享元对象。


4:享元工厂(FlyweightFactoiy)角色：
本角色负责创建和管理享元角色。
本角色必须保证享元对象可以被系统适当地共享。
当一个客户端对象请求一个享元对象的时候，享元工厂角色需要检查系统中是否已经有一个符合要求的享元对象，
如果已经有了，享元工厂角色就应当提供这个已有的享元对象；
如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个新的合适的享元对象。


5:客户端(Client)角色：
本角色还需要自行存储所有享元对象的外蕴状态。



============================================================================

享元模式的优点:
大幅度地降低内存中对象的数量。


享元模式的缺点: 
1、享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。
2、享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。


总结：
享元模式一般是解决系统性能问题的，所以经常用于底层开发，在项目开发中并不常用。
